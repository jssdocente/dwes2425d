# 7. AutoLoading, Namespaces y Models

En esta 6춹 lecci칩n vamos a ver c칩mo podemos utilizar el autoloading de clases, los namespaces y los modelos en Laravel.

### Recursos

---

## Crear un modelo

### Compartir la lista de notas

Si recordamos el punto anterior, tenemos 2 rutas, una para ver el listado de notas y otra para ver una nota, donde tenemos duplicado la lista de notas. Esto no es lo m치s aconsejable, por lo que vamos a solucionarlo.

Vamos a pasar la lista de notas, a un nivel superior, directamente definido en el fichero `web.php` (temporalmente).

```php
// routes/web.php
<?php

use Illuminate\Support\Arr;
use Illuminate\Support\Facades\Route;

$notes = [
        ['id' => 1, 'title' => 'Nota 1', 'body' => 'Contenido de la nota 1'],
        ['id' => 2, 'title' => 'Nota 2', 'body' => 'Contenido de la nota 2'],
        ['id' => 3, 'title' => 'Nota 3', 'body' => 'Contenido de la nota 3']
];

Route::get('/notes', function () use ($notes) {
    return view('notes.index', ['notes' => $notes]);
});

Route::get('/notes/{id}', function ($id) use ($notes) {

    $note = Arr::first($notes, fn ($note) => $note['id'] == $id);

    return view('notes.show', ['note' => $note]);
});

//resto del c칩digo
```

> 游댠游댠 Aqu칤 se ha utilizado un concepto un poco avanzado, y es que al utilizar un `closure`, hemos tenido que usar la directiva `use ($notes)` para que la variable $notes, definida fuera de la funci칩n pueda ser utilizada dentro de la misma. 


Ahora si volvemos a probar todo deber칤a funcionar igual que antes.

Esta soluci칩n est치 bien, pero podemos mejorarla.

### Crear una clase Nota

Podemos encapsular el acceso a la lista de notas a trav칠s de una clase, y que la lista de notas sea un atributo de la clase.

Vamos a crear una clase `Nota` en el mismo fichero `web.php`.

En la clase, creamos un m칠todo est치tico `all()` que devolver치 la lista de notas. Y ahora refactorizar el c칩digo para que utilice esta clase y el m칠todo `all()`.

```php
class Notes {

    public static function all() {
        return [
            ['id' => 1, 'title' => 'Nota 1', 'body' => 'Contenido de la nota 1'],
            ['id' => 2, 'title' => 'Nota 2', 'body' => 'Contenido de la nota 2'],
            ['id' => 3, 'title' => 'Nota 3', 'body' => 'Contenido de la nota 3']
        ];
    }
}

Route::get('/notes', function () {
    return view('notes.index', ['notes' => Notes::all()]);
});

Route::get('/notes/{id}', function ($id) {
    $note = Arr::first(Notes::all(), fn ($note) => $note['id'] == $id);
    return view('notes.show', ['note' => $note]);
});
```

Aplica estos cambios y comprueba que todo sigue funcionando correctamente.

### Mover la clase al directorio correcto

Esta clase Notes, que se encarga de gestionar los datos que se van a utilizar en los procesos, y se mostrar치n en las vistas es lo que se conoce como un `modelo`. Si recordamos la arquitectura MVC, el modelo es la capa que se encarga de gestionar los datos de la aplicaci칩n.

Hasta ahora hemos creado la clase `Notes` en el mismo fichero `web.php`, pero esto no es lo m치s correcto. En Laravel, los modelos se deben almacenar en el directorio `app/Models`.

Crea con PHPStorm una nueva clase en el directorio `app/Models` llamada `Note.php` y copia el contenido de la clase `Notes` a esta nueva clase.

> 游댠 Hemos renombrado la clase, de Notes a Note. Todos los modelos/clases deben ir en singular.

Si te fijas, ver치s que autom치ticamente PHPStorm ha a침adido un `namespace` al principio de la clase. Esto es lo que se conoce como `namespace`, y es una forma de organizar las clases en directorios.

El namespaces que ha a침adido PHPStorm es `App\Models`, que es el directorio donde hemos creado la clase.

**AutoLoad de Clases**

En Laravel, el autoloading de clases se realiza autom치ticamente, por lo que no es necesario hacer nada m치s para que las clases se carguen autom치ticamente.

Si revisamos el fichero `composer.json`, veremos que hay una secci칩n `autoload` que se encarga de cargar las clases autom치ticamente.

En esta secci칩n, existe una clave `psr-4`, y dentro de ella, una lista de todos los namespaces y su carpeta correspondiente.

```json
// composer.json
{
  //resto del c칩digo
},
 "autoload": {
        "psr-4": {
            "App\\": "app/",
            "Database\\Factories\\": "database/factories/",
            "Database\\Seeders\\": "database/seeders/"
        }
    },
```

Lo que dice este extracto de c칩digo, es que el namespace `App` se encuentra en la carpeta `app/`, y por tanto, todas las clases que tengan el namespace `App` se deben encontrar en la carpeta `app/`. Autom치ticamente, Laravel cargar치 las clases que se encuentren en esta carpeta.

**Usar el modelo Note**

Ahora que tenemos el modelo `Note` en el directorio correcto, vamos a utilizarlo en el fichero `web.php`.

Refactoriza el c칩digo, importando la clase `Note` y utilizando el m칠todo `all()`.

Prueba, y todo deber칤a seguir funcionando correctamente.


## Mover la l칩gica de filtrado a la clase Note

Si revisamos el c칩digo, vemos que en la ruta `/notes/{id}`, estamos filtrando la nota que queremos mostrar, utilizando la funci칩n `Arr::first()`. Esto no es lo m치s correcto, ya que la l칩gica de filtrado deber칤a estar en el modelo `Note`.

Vamos a a침adir un nuevo m칠todo a la clase `Note` llamado `find()` que reciba un `id` y devuelva la nota correspondiente.

```php
// app/Models/Note.php
namespace App\Models;

class Note {

    public static function all() {
        return [
            ['id' => 1, 'title' => 'Nota 1', 'body' => 'Contenido de la nota 1'],
            ['id' => 2, 'title' => 'Nota 2', 'body' => 'Contenido de la nota 2'],
            ['id' => 3, 'title' => 'Nota 3', 'body' => 'Contenido de la nota 3']
        ];
    }

    public static function find($id): array {
        return Arr::first(self::all(), fn ($note) => $note['id'] == $id);
    }
}
```

Ahora, en el fichero `web.php`, refactoriza el c칩digo para que utilice el m칠todo `find()`.

Comprueba que todo sigue funcionando correctamente.

**Nota no encontrada**

쯈u칠 pasa si el id no existe? Laravel nos devuelve un error, ya que la funci칩n `Arr::first()` no encuentra ning칰n valor.

Para solucionar esto, podemos seguir la misma idea que seguimos en el proyecto WebApp, y devolver un c칩digo HTTP 404 si no se encuentra la nota.

쮺칩mo podemos hacer esto en Laravel?<br>
Laravel nos proporciona una funci칩n llamada `abort()` que nos permite abortar la ejecuci칩n de la aplicaci칩n y devolver un c칩digo HTTP. 游뱂 쯊e suena de algo? Siiii... es la misma funci칩n que ten칤amos en el proyecto anterior... que cracks somos. Las buenas pr치cticas son ampliamente utilizadas.

Entonces, si no se encuentra la nota, devolvemos un c칩digo HTTP 404.

Refactoriza el c칩digo, dentro del m칠todo `find` para que devuelva un c칩digo HTTP 404 si no se encuentra la nota, utilizando la funci칩n `abort()`.

El resultado final se muestra en la siguiente imagen.

![Nota no encontrada](./img/12.note-not-found.gif)