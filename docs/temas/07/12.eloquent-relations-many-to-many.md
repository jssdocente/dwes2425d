# 12. Eloquent: Relaci√≥n Many to Many

En esta 12¬™ lecci√≥n vamos a ver c√≥mo podemos utilizar las relaciones `Many to Many` en Eloquent, para relacionar los modelos entre s√≠.

### Recursos

- [Eloquent Relaci√≥n Many-to-many](https://laravel.com/docs/11.x/eloquent-relationships#many-to-many)

---

## Relaci√≥n Many to Many

Una relaci√≥n `Many to Many` es una relaci√≥n donde varios registros de una tabla se relacionan con varios registros de otra tabla.

Por ejemplo, en una aplicaci√≥n de m√∫sica, un `Album` puede tener varios `Artistas`, y un `Artista` puede tener varios `Albums`. En estas relaciones, es necesario una tabla intermedia que relacione los `Albums` con los `Artistas`. Esta tabla intermedia se llama tabla `pivot`.

En Eloquent, para definir una relaci√≥n `Many to Many`, necesitamos definir 2 m√©todos en los modelos que representan la relaci√≥n. Un m√©todo en el modelo `Album`, y otro m√©todo en el modelo `Artista`. Adem√°s, necesitamos definir la tabla `pivot` que relaciona los `Albums` con los `Artistas`. 


![Many to Many](./img/14.eloquent.many-to-many-1.png)

Otro ejemplo muy com√∫n, es un Post que puede tener varios Tags, y un Tag puede tener varios Posts. 

![Many to Many](./img/15.eloquent.many-to-many-2.png)

La convenci√≥n de nombres para la tabla pivot es el nombre de los modelos en orden alfab√©tico en singular, separados por guiones bajos. Por ejemplo, si tenemos los modelos `Album` y `Artista`, la tabla pivot se llamar√° `album_artista`, para el caso de los modelos `Post` y `Tag`, la tabla pivot se llamar√° `post_tag`.

![Many to Many](./img/16.eloquent.many-to-many-3.png)


> üí° Es muy recomendable siempre hacerlo en ingl√©s y en singular, y respectando las reglas gramiticales de los plurales e irregulares, para no tener que hacer ninguna configuraci√≥n adicional.


## Crear una relaci√≥n Many to Many

En nuestro ejemplo de Notas, vamos a crear una relaci√≥n `Many to Many` entre las tablas `notes` y `tags`. Una nota puede tener varios tags, y un tag puede tener varias notas. Para ello, necesitamos una tabla intermedia `note_tag` que relacione las notas con los tags.

Por tanto, lo primero que necestiamos crear es el modelo `Tag` y adem√°s vamos a crear en el mismo comando la migraci√≥n y el factory.

```bash
php artisan make:model Tag -mf
```

**Crear la tabla Tag**

Si revisams veremos una migraccion `create_tags_table.php` en la carpeta `database/migrations`, que contiene el siguiente c√≥digo:

La tabla `tags` tiene 2 campos, `id` y `name`.

```php
/**
 * Run the migrations.
 */
public function up(): void
{
    Schema::create('tags', function (Blueprint $table) {
        $table->id();
        $table->string('name')->unique();
        $table->timestamps();
    });
}

/**
 * Reverse the migrations.
 */
public function down(): void
{
    Schema::dropIfExists('tags');
}
```

Tenemos la tabla `tags` y la tabla `notes`, ahora necesitamos una tabla intermedia que conecte ambas tablas. La tabla intermediaria se llamar√° `note_tag`. En esta tabla, necesitamos al menos 2 campos, los identificadores de las tablas relacionadas, `note_id` y `tag_id`. Adem√°s si queremos controlar cuando se actualizan estos campos, podemos agregar campos de tiempo, `created_at` y `updated_at`.

Modificamos la migraci√≥n para incluir la tabla `note_tag`.

```php
/**
 * Run the migrations.
 */
public function up(): void
{
    Schema::create('tags', function (Blueprint $table) {
        $table->id();
        $table->string('name');
        $table->timestamps();
    });

     Schema::create('note_tag', function (Blueprint $table) {
            $table->id();
            $table->foreignIdFor(Note::class);
            $table->foreignIdFor(Tag::class);
            $table->timestamps();
        });
}

/**
 * Reverse the migrations.
 */
public function down(): void
{
    Schema::dropIfExists('note_tag');
    Schema::dropIfExists('tags');
}
```

Ahora, ejecutamos la migraci√≥n para crear las tablas.

```bash
php artisan migrate
```

Si revisamos la base de datos, veremos que se han creado las tablas `tags` y `note_tag`.

### Aplicar eliminaci√≥n en cascada

En las tablas intermedias, es posible que queramos aplicar eliminaci√≥n en cascada, para que cuando se elimine un registro de una tabla, se eliminen autom√°ticamente los registros relacionados en la tabla intermedia.

Para ello, podemos modificar la migraci√≥n de la tabla intermedia, y a√±adir las claves for√°neas con la opci√≥n `onDelete('cascade')`.

```php
/**
 * Run the migrations.
 */
public function up(): void
{
    Schema::create('tags', function (Blueprint $table) {
        $table->id();
        $table->string('name');
        $table->timestamps();
    });

     Schema::create('note_tag', function (Blueprint $table) {
            $table->id();
            //Eliminar en cascada cuando se elimina una nota
            $table->foreignIdFor(\App\Models\Note::class)->constrained()->cascadeOnDelete();
            //Eliminar en cascada cuando se elimina un tag
            $table->foreignIdFor(\App\Models\Tag::class)->constrained()->cascadeOnDelete();
            $table->timestamps();
        });
}

/**
 * Reverse the migrations.
 */
public function down(): void
{
    Schema::dropIfExists('note_tag');
    Schema::dropIfExists('tags');
}
```

Normalmente, en este tipo de tablas intermedias, no se permite repetir las combinaciones de claves for√°neas, por lo que podemos a√±adir una clave √∫nica para evitar duplicados. Para ello utilizamos el m√©todo `unique(['note_id', 'tag_id'])`, o si no queremos tener una campo id, podemos utilizar esta clave como clave primaria.

Un ejemplo de esto ser√≠a el siguiente:

```php
/**
 * Run the migrations.
 */
public function up(): void

{
    Schema::create('tags', function (Blueprint $table) {
        $table->id();
        $table->string('name');
        $table->timestamps();
    });

    //Opci√≥n 1: Clave √∫nica
    Schema::create('note_tag', function (Blueprint $table) {
        $table->id();
        $table->foreignIdFor(\App\Models\Note::class)->constrained()->cascadeOnDelete();
        $table->foreignIdFor(\App\Models\Tag::class)->constrained()->cascadeOnDelete();
        $table->unique(['note_id', 'tag_id']);
        $table->timestamps();
    });

    //Opci√≥n 2: Clave primaria
    Schema::create('note_tag', function (Blueprint $table) {
        $table->foreignIdFor(\App\Models\Note::class)->constrained()->cascadeOnDelete();
        $table->foreignIdFor(\App\Models\Tag::class)->constrained()->cascadeOnDelete();
        $table->primary(['note_id', 'tag_id']);
        $table->timestamps();
    });
}
```	

En nuestro caso vamos a optar por la opci√≥n 1, y a√±adir una clave √∫nica a la tabla `note_tag`, quedando as√≠ la migraci√≥n:

```php
public function up(): void

{
    Schema::create('tags', function (Blueprint $table) {
        $table->id();
        $table->string('name');
        $table->timestamps();
    });

    //Opci√≥n 1: Clave √∫nica
    Schema::create('note_tag', function (Blueprint $table) {
        $table->id();
        $table->foreignIdFor(\App\Models\Note::class)->constrained()->cascadeOnDelete();
        $table->foreignIdFor(\App\Models\Tag::class)->constrained()->cascadeOnDelete();
        $table->unique(['note_id', 'tag_id']);
        $table->timestamps();
    });
}
```




Para volver a re-aplicar la migraci√≥n, hacemos primero un rollback y luego volvemos a ejecutar la migraci√≥n.

```bash
php artisan migrate:rollback
php artisan migrate
```

> üí° Por defecto, en SQLite, las restricciones de clave for√°nea no est√°n activadas por defecto. Para activarlas ejecutar el comando `PRAGMA foreign_keys=on`


## Definir la relaci√≥n Many to Many

Ahora que tenemos las tablas `notes`, `tags` y `note_tag`, vamos a definir la relaci√≥n `Many to Many` en los modelos `Note` y `Tag`.

Una nota puede tener varios tags, y un tag puede tener varias notas. Por tanto, en el modelo `Note`, vamos a definir un m√©todo `tags()` que devuelva todos los tags de una nota.

La relaci√≥n `Many to Many` en Eloquent se define con el m√©todo `belongsToMany()`. Tenemos que definir en √°mbos modelos la relaci√≥n, en el modelo `Note` y en el modelo `Tag`.

Una Nota tendr√° varios Tags, y un Tag tendr√° varias Notas.

```php
// app/Models/Note.php
class Note extends Model {

    use HasFactory;

    protected $fillable = ['title', 'body'];

    public function user(): BelongsTo {
        return $this->belongsTo(User::class);
    }

    public function tags(): BelongsToMany {
        return $this->belongsToMany(Tag::class);
    }

}

// app/Models/Tag.php
class Tag extends Model
{
    use HasFactory;
    
    public function notes(): BelongsToMany {
        return $this->belongsToMany(Note::class);
    }
}
```

## Agregar Elementos a la tabla pivot

Para a√±adir elementos a la tabla pivot, utilizamos el m√©todo `attach()`. Este m√©todo recibe el identificador del modelo relacionado, o la instancia del modelo relacionado.

Vamos a trabajar con ello primero desde Tinker.

```bash
php artisan tinker
```

```php
use App\Models\Note;
use App\Models\Tag;

$note = Note::find(1);
//Crear varios tags
$tag1 = Tag::firstOrCreate(['name' => 'Laravel']);
$tag2 = Tag::firstOrCreate(['name' => 'PHP']);
$tag3 = Tag::firstOrCreate(['name' => 'Eloquent']);

//A√±adir un tag a una nota
$note->tags()->attach($tag1); //devuelve null

//Si ejecutamos este comando nuevamente, dar√° un error, ya que no se pueden repetir las combinaciones
$note->tags()->attach($tag1); //ERROR

//A√±adir varios tags a una nota
$note->tags()->attach([$tag2->id, $tag3->id]);

//Eliminar un tag de una nota
$note->tags()->detach($tag1);

//o a trav√©s del id
$note->tags()->detach($tag2->id);

//Para acceder a los tags de una nota
$note->tags;  //sin par√©ntesis como si fuera una propiedad
```

Si ejecutamos el comando `$note->tags`, veremos que nos devuelve una sola Tag, ¬øpor qu√©?, porque hemos obtenido la Nota con el id 1, y posteriormente hemos agregado elementos a la relaci√≥n, pero no hemos vuelto a obtener la Nota, por lo que no se han refrescado los datos.

Para refrescar los datos, podemos hacer un `refresh()`.

```php
$note->refresh();

$note->tags;
= Illuminate\Database\Eloquent\Collection {#6222
    all: [
      App\Models\Tag {#6398
        id: 1,
        name: "Laravel",
        created_at: "2024-12-25 13:22:04",
        updated_at: "2024-12-25 13:22:04",
        pivot: Illuminate\Database\Eloquent\Relations\Pivot {#6262
          note_id: 1,
          tag_id: 1,
        },
      },
      App\Models\Tag {#6395
        id: 2,
        name: "PHP",
        created_at: "2024-12-25 13:22:18",
        updated_at: "2024-12-25 13:22:18",
        pivot: Illuminate\Database\Eloquent\Relations\Pivot {#6399
          note_id: 1,
          tag_id: 2,
        },
      },
      App\Models\Tag {#6394
        id: 3,
        name: "Eloquent",
        created_at: "2024-12-25 13:26:45",
        updated_at: "2024-12-25 13:26:45",
        pivot: Illuminate\Database\Eloquent\Relations\Pivot {#6400
          note_id: 1,
          tag_id: 3,
        },
      },
    ],
  }
```

Ahora s√≠, vemos que tenemos los 3 tags asociados a la nota.

### M√©todo Toggle

Otro m√©todo que podemos utilizar para a√±adir o eliminar elementos de la tabla pivot, es el m√©todo `toggle()`. Este m√©todo a√±ade un elemento si no existe, y lo elimina si ya existe. Es muy √∫til cuando queremos asociar o desasociar elementos de una relaci√≥n. 

```php
//A√±adir o eliminar un tag de una nota.
$note->tags()->toggle($tag1);

//A√±adir o eliminar varios tags de una nota.
$note->tags()->toggle([$tag2->id, $tag3->id]);

//Devuelve un array con 2 claves, attached y detached, con los elementos a√±adidos y eliminados.
//En este caso, se han eliminado los tags 1 y 2.
= [
    "attached" => [],
    "detached" => [
      1,
      2,
    ],
  ]

//Si volvemos a ejecutar el comando, se a√±adir√°n los tags 1 y 2.
$note->tags()->toggle([$tag2->id, $tag3->id]);
= [
    "attached" => [
      1,
      2,
    ],
    "detached" => [],
  ]
```

### M√©todo Sync

El m√©todo `sync()` nos permite sincronizar los elementos de la tabla pivot. Este m√©todo recibe un id/instancia o un array de ids/instancias, y elimina los elementos que no est√©n en el array. Es decir, solo deja los elementos que le pasamos en el array.

```php
//Solo deja los tags 2 y 3, y elimina el resto de tags asociados a la nota.
$note->tags()->toggle([1,3]);
```	

### M√©todo SyncWithoutDetaching

El m√©todo `syncWithoutDetaching()` es similar al m√©todo `sync()`, pero no elimina los elementos que no est√°n en el array. Es decir, a√±ade los elementos que le pasamos en el array, y mantiene los elementos que ya estaban asociados.

```php
//A√±ade los tags 1 y 3,
$note->tags()->sync([1,3]);

//Si queremos a√±adir el tag-1 y el tag-2, pero no borrar el resto de tags que tuviera.
$note->tags()->syncWithoutDetaching([1,2]);
```

Es √∫til, cuando queremos a√±adir elementos a una relaci√≥n, pero no queremos eliminar los elementos que ya est√°n asociados.


### Activar los timestamps en la tabla pivot

Por defecto, las tablas pivot no tienen activados los campos `created_at` y `updated_at`. Si queremos activar estos campos, podemos hacerlo a trav√©s del m√©todo `withTimestamps()`.

```php
// app/Models/Note.php
class Note extends Model {

    use HasFactory;

    protected $fillable = ['title', 'body'];

    public function user(): BelongsTo {
        return $this->belongsTo(User::class);
    }

    public function tags(): BelongsToMany {
        return $this->belongsToMany(Tag::class)->withTimestamps();
    }
}

// app/Models/Tag.php
class Tag extends Model
{
    use HasFactory;

    protected $fillable = ['name'];

    public function notes(): BelongsToMany {
        return $this->belongsToMany(Note::class)->withTimestamps()
    }
}
```

Para la relaci√≥n inversa, entre el modelo `Tag` y el modelo `Note`, tambi√©n podemos activar los timestamps en la relaci√≥n entre Tags y Notes.


## Almacenar datos adicionales en la tabla pivot

A veces es necesario almacenar informaci√≥n adicional en la tabla intermediaria, adem√°s de los identificadores de las tablas relacionadas. Por ejemplo, en una relaci√≥n entre `Albums` y `Artistas`, podemos querer almacenar la fecha en la que se lanz√≥ el √°lbum, o el n√∫mero de canciones que tiene el √°lbum.

En nuestro caso queremos saber la fecha en la que se a√±adi√≥ un tag a una nota, por lo que necesitamos a√±adir un campo `added_at` a la tabla `note_tag`. (se podr√≠a conocer por el campo `created_at` de la tabla pivot, pero vamos a a√±adirlo para ver c√≥mo se hace).

Para ello, necesitamos modificar la migraci√≥n de la tabla `note_tag`, y a√±adir el campo `added_at`.

```php
/**
 * Run the migrations.
 */
public function up(): void

{
    Schema::create('tags', function (Blueprint $table) {
        $table->id();
        $table->string('name');
        $table->timestamps();
    });

    //Opci√≥n 1: Clave √∫nica
    Schema::create('note_tag', function (Blueprint $table) {
        $table->id();
        $table->foreignIdFor(\App\Models\Note::class)->constrained()->cascadeOnDelete();
        $table->foreignIdFor(\App\Models\Tag::class)->constrained()->cascadeOnDelete();

        //A√±adir el campo added_at
        $table->timestamp('added_at')->nullable();

        $table->unique(['note_id', 'tag_id']);
        $table->timestamps();
    });
}
```	

Para reaplicar la migraci√≥n, hacemos un rollback y volvemos a ejecutar la migraci√≥n.

```bash
php artisan migrate:rollback && php artisan migrate
```

Ahora si queremos agregar este campo a la tabla pivot, necesitamos modificar el m√©todo `attach()` y a√±adir el campo `added_at`.

```php
// app/Models/Note.php
class Note extends Model {

    use HasFactory;

    protected $fillable = ['title', 'body'];

    public function user(): BelongsTo {
        return $this->belongsTo(User::class);
    }

    public function tags(): BelongsToMany {
        //Devemos indicar el campo added_at en la relaci√≥n si lo queremos obtener
        return $this->belongsToMany(Tag::class)->withTimestamps()
        ->withPivot('added_at');
    }
}
```

Si queremos a√±adir un tag a una nota, y adem√°s a√±adir la fecha en la que se a√±adi√≥, podemos hacerlo de la siguiente forma:

```php
$note->tags()->attach($tag1, ['added_at' => now()]);
```

La informaci√≥n adicional, se necesita pasar un array con toda la informaci√≥n `extra` que se quiere a√±adir.



## En resumen

En esta lecci√≥n hemos visto c√≥mo podemos utilizar las relaciones `Many to Many` en Eloquent, para relacionar los modelos entre s√≠.

![Many to Many](./img/17.eloquent.many-to-many-4.png)


