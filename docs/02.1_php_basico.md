# El lenguaje PHP

PHP es un lenguaje de programaci√≥n de prop√≥sito general, aunque su fuerte es el desarrollo web. 

Principales caracter√≠sticas:

- **Acr√≥nimo de** *Personal Home Page*
- **Sintaxis** similar a C / Java
- **Interpretado** en el servidor
- **Debilmente tipado** (no es necesario declarar el tipo de dato de una variable antes de usarla)

### Tipado din√°mico y debil

Un *lenguaje es din√°micamente tipado* cuando es √©l quien deduce el tipo de datos de las variables y no se lo tenemos que indicar nosotros. En el siguiente ejemplo vemos como PHP estar√≠a deduciendo el tipo resultante de sumar un int y un string que contiene un entero:

var_dump(1 + "1"); // Output: int(2)

Al ser din√°micamente tipado, adem√°s de interpretado, PHP no tiene un proceso de compilaci√≥n, si no que es en tiempo de ejecuci√≥n cuando PHP valida si una determinada variable tiene un determinado m√©todo, o no. Esto se conoce como [Duck Typing](https://ericlippert.com/2014/01/02/what-is-duck-typing/):

M√°s adelante trataremos el tema de las variables y su tipado.

### C√≥digo embebido

Los bloques de c√≥digo se escriben entre **`<?php`** y **`?>`**, mientras que las sentencias se separan mediante **`;`**.

``` html+php
<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>PHP f√°cil</title>
</head>
<body>
<!-- Muestra una frase con HTML -->
Hola mundo<br>
<!-- Muestra una frase con PHP -->
<?php echo "Es muy f√°cil programar en PHP."; ?>
</body>
</html>
```

!!! tip "S√≥lo etiquetas de apertura"
    Si nuestro c√≥digo s√≥lo va a contener c√≥digo PHP y nada de html, como por ejemplo, cuando codifiquemos clases o interfaces, s√≥lo pondremos la etiqueta de apertura, para as√≠ indicar que es una archivo de php puro.

!!! success "Compilador online"
    Podemos [probar online](https://www.programiz.com/php/online-compiler/) sin tener que configurar nada en local.

### Generando contenido

Tenemos tres posibilidades a la hora de generar contenido en nuestros documentos PHP:

* **`echo`**`expresi√≥n;`
* **`print`**`(expresi√≥n);`
* **`<?=`**` expresi√≥n ?>`

Las que vamos a utilizar son `echo` cuando lo hagamos dentro de un bloque de instrucciones y `<?=` cuando s√≥lo vayamos a mostrar el valor de una variable dentro de un fragmento HTML.

``` html+php
<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Echo y print</title>
</head>
<body>
<p><?php echo "Este texto se mostrar√° en la p√°gina web." ?></p>
<p><?= "Este texto se mostrar√° en la p√°gina web." ?></p>
<p><?php print("Este texto se mostrar√° en la p√°gina web.") ?></p>
</body>
</html>
```

### Comentarios

Podemos utilizar comentarios de una l√≠nea o de bloque:

``` html+php
<?php
// Este es un comentario de una sola l√≠nea
/*
  Este es
  un comentario
  que ocupa
  varias l√≠neas
*/ 
?>
```

### Errores

Si hay un error de ejecuci√≥n, se produce un *Fatal Error*.

``` console
Fatal error: Uncaught Error: Call to undefined function plint() in C:\xampp\htdocs\202echo.php:11
 Stack trace:
 #0 {main}
	thrown in C:\xampp\htdocs\202echo.php on line 11
```

Desde PHP 5 se lanzan como una excepci√≥n. M√°s adelante veremos el uso de `try` / `catch`.

### Variables

* No es necesario declararlas previamente.
* Comienzan por `$`, por ejemplo `$nombre`. Tras el `$`, el siguiente caracter debe ser una letra en min√∫scula (recomendaci√≥n) o gui√≥n bajo `_`. Luego ya se pueden poner n√∫meros.
* Son *case sensitive*: `$var != $vAR`
* No se declara su tipo, el tipado es din√°mico. Se asigna en tiempo de ejecuci√≥n dependiendo del valor asignado.
* Conveniente inicializarlas, sino dan error.

``` php
<?php
$nombre = "Aitor";
$nombreCompleto = "Aitor Medrano";
$numero = 123;
$numero2 = 456;
$pi = 3.14;
$suerte = true;
$sinValor;

echo $sinValor;
?>
```

> Aunque a priori no hay tipos de datos, internamente PHP trabaja con cuatro tipos escalares: *boolean*, *integer*, *float* y *string* y cuatro tipos compuestos: *array*, *object*, *callable* e *iterable*. Existe un tipo especial para *null* (m√°s informaci√≥n en <http://php.net/manual/es/language.types.null.php>).


!!! question "¬øQu√© mostrar√° el siguiente c√≥digo?"

    Indica qu√© mostrar√° el siguiente c√≥digo:

    ```html
    <!DOCTYPE html>
    <html lang="en">
        <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
    </head>

    <body>
        <?php
        
        $bookName= "Harry Potter";
        $read = false;

        if ($read) {
            $message = "Has leido el libro $bookName";
        }

        ?>
        <h1>
            <?php echo $message; ?>  
        </h1>
    </body>

    </html>
    ```
    En la l√≠nea 17, ¬øc√≥mo podr√≠as simplificar esa expresi√≥n?



#### Declaraci√≥n de Tipos (antes llamado Type Hinting)

A partir de PHP 5.0 tenemos la posibilidad de especificar el tipo de datos que contiene una determinada variable al ser recibida como argumento. Esto aporta cierta robustez a los contratos de nuestros m√©todos y deja atr√°s la posibilidad del Duck Typing tal. A pesar de ser un avance, segu√≠a teniendo sus limitaciones: S√≥lo se pod√≠an especificar clases o interfaces (POO), en ning√∫n caso tipos primitivos del lenguaje.

- PHP 5.1 introdujo la posibilidad de especificar array como tipo de entrada
- PHP 7.0 introdujo soporte a primitivos como bool, string, int, y float

**Strit Types**

Otra funcionalidad al respecto de tipos incorporada en PHP 7.0 es la sentencia declare(strict_types=1);. Esta sentencia evita castings autom√°ticos que hace PHP en caso de no especificar esta sentencia.

**Nullable Types**

PHP 7.1 introduce la posibilidad de especificar de forma expl√≠cita que un determinado tipo puede ser null. Para ello se a√±ade un s√≠mbolo de interrogaci√≥n (?) en la declaraci√≥n del tipo.

Todo estos puntos se ir√°n viendo a lo largo estos primeros temas.

!!! info "+ sobre tipos"
    En esta presentaci√≥n se explica mucho m√°s en profundidad el tema del [Tipado Stricto](https://docs.google.com/presentation/d/19swiEPdFm0yKqrUH7k5GSvFa3slq9607e8ZyPakv7Ww/htmlpresent)

### Constantes

Son variables cuyo valor no var√≠an. Existen dos posibilidades:

* `define(NOMBRE, valor);`
* `const NOMBRE; // PHP > 5.3`

``` php
<?php
define("PI", 3.1416);
const IVA = 0.21;

echo PI, " ", IVA; // No se pone el s√≠mbolo dolar
?>
```

* Se declaran siempre en MAY√öSCULAS
* Hay un conjunto de constantes ya predefinidas, tambi√©n conocidas como *magic constants*: <https://www.php.net/manual/es/language.constants.predefined.php>

## Operadores

### Arim√©ticos

| Ejemplo    | Nombre         | Resultado                                     |
| ---------- | -------------- | --------------------------------------------- |
| `-$a`      | Negaci√≥n       | Opuesto de `$a`.                              |
| `$a + $b`  | Suma           | Suma de `$a` y `$b`.                          |
| `$a - $b`  | Resta          | Diferencia de `$a` y `$b`.                    |
| `$a * $b`  | Multiplicaci√≥n | Producto de `$a` y `$b`.                      |
| `$a / $b`  | Divisi√≥n       | Cociente de `$a` y `$b`.                      |
| `$a % $b`  | M√≥dulo / Resto | Resto de `$a` dividido por `$b`.              |
| `$a ** $b` | Potencia       | Resultado de `$a` elevado a `$b`. PHP >= 5.6. |

En el caso de **cadenas**, si queremos concatenarlas, se utiliza el operador `.`:

``` php
<?php
$x = 33;
$y = 11;
$z = $x + $y;
echo "La suma de 33 y 11 es ".44."<br />";
echo "La suma de ".$x." y ".$y." es ".(33 + 11)."<br />";
echo "La suma de ".$x." y ".$y." es ".$z."<br />";
?>
```

Realmente, en vez de concatenar cadenas con variables, podemos imprimirlas directamente ya que se expanden autom√°ticamente:
``` php
<?php
echo "La suma de $x y $y es $z <br />";
?>
```

En ocasiones, necesitamos rodear el nombre de la variable entre llaves para poder unir m√°s texto al resultado:

``` php
<?php
$color = "rojo";
echo "El plural de $color el {$color}s";
?>
```

M√°s adelante estudiaremos algunas funciones para el tratamiento de cadenas.

### Comparaci√≥n

| Ejemplo                | Nombre                         | Resultado                                                                                                                           |
| ---------------------- | ------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------- |
| `$a == $b`             | Igual                          | `true` si `$a` es igual a `$b` tras de la conversi√≥n de tipos.                                                                      |
| `$a === $b`            | Id√©ntico, Comparaci√≥n estricta | `true` si `$a` es igual a `$b`, y son del mismo tipo de dato.                                                                       |
| `$a != $b`, `$a <> $b` | Diferente                      | `true` si `$a` no es igual a `$b` despu√©s de la conversi√≥n de tipos.                                                                |
| `$a !== $b`            | No id√©ntico                    | `true` si `$a` no es igual a `$b`, o si no son del mismo tipo.                                                                      |
| `$a < $b`              | Menor que                      | `true` si `$a` es estrictamente menor que `$b`.                                                                                     |
| `$a > $b`              | Mayor que                      | `true` si `$a` es estrictamente mayor que `$b`.                                                                                     |
| `$a <= $b`             | Menor o igual que              | `true` si `$a` es menor o igual que `$b`.                                                                                           |
| `$a >= $b`             | Mayor o igual que              | `true` si `$a` es mayor o igual que `$b`.                                                                                           |
| `$a <=> $b`            | Nave espacial                  | Devuelve `-1`, `0` o `1` cuando `$a` es respectivamente menor, igual, o mayor que `$b`. PHP >= 7.                                   |
| `$a ?? $b ?? $c`       | Fusi√≥n de *null*               | El primer operando de izquierda a derecha que exista y no sea `null`. `null` si no hay valores definidos y no son `null`. PHP >= 7. |

### L√≥gicos

| Ejemplo                 | Nombre              | Resultado                                       |
| ----------------------- | ------------------- | ----------------------------------------------- |
| `$a and $b`, `$a && $b` | *And* (y)           | `true` si tanto `$a` como `$b` son `true`.      |
| `$a or $b`, `$a         |                     | $b`                                             | *Or* (o inclusivo) | `true` si cualquiera de `$a` o `$b` es `true`. |
| `$a xor $b`             | *Xor* (o exclusivo) | `true` si `$a` o `$b` es `true`, pero no ambos. |
| `!$a`                   | *Not* (no)          | `true` si `$a` no es `true`.                    |

### Asignaci√≥n

| Ejemplo    | Nombre                    | Resultado                                                                       |
| ---------- | ------------------------- | ------------------------------------------------------------------------------- |
| `$a = $b`  | Asignaci√≥n                | Asigna a `$a` el valor de `$b`                                                  |
| `$a += $b` | Asignaci√≥n de la suma     | Le suma a `$a` el valor de `$b`. Equivalente a `$a = $a + $b`                   |
| `$a -= $b` | Asignaci√≥n de la resta    | Le resta a `$a` el valor de `$b`. Equivalente a `$a = $a - $b`                  |
| `$a *= $b` | Asignaci√≥n del producto   | Asigna a `$a` el producto de `$a` por `$b`. Equivalente a `$a = $a * $b`        |
| `$a /= $b` | Asignaci√≥n de la divisi√≥n | Asigna a `$a` el conciente de `$a` entre `$b`. Equivalente a `$a = $a / $b`     |
| `$a %= $b` | Asignaci√≥n del resto      | Asigna a `$a` el resto de dividir `$a` entre `$b`. Equivalente a `$a = $a % $b` |
| `$a .= $b` | Concatenaci√≥n             | Concatena a `$a` la cadena `$b`. Equivalente a `$a = $a . $b`                   |
| `$a++`     | Incremento                | Incrementa `$a` en una unidad. Equivalente a `$a = $a + 1`                      |
| `$a--`     | Decremento                | Decrementa `$a` en una unidad. Equivalente a `$a = $a - 1`                      |

!!! Tip "Prioridad de los operadores"
    Recuerda la prioridad. Primero los par√©ntesis, luego la negaci√≥n (`!`), productos/divisiones, sumas/restas, comparaciones, l√≥gicos y por √∫ltimo se realiza la asignaci√≥n.
    M√°s informaci√≥n en <https://www.php.net/manual/es/language.operators.precedence.php>

!!! question "Autoevaluaci√≥n"
    Si `$a=5` y `$b=4`, averigua el valor de `$c` si `$c = $a*2 > $b+5 && !($b<>4)`


## Condiciones

La condici√≥n simple se realiza mediante la instrucci√≥n `if`. Entre par√©ntesis se pone la condici√≥n que se evalua a `true` o `false`. Si no se ponen llaves, en vez de abrir un bloque, se ejecutar√° s√≥lo la siguiente instrucci√≥n.

!!! warning "Siempre llaves"
    Es recomendable poner llaves siempre aunque en el momento de codificar s√≥lo haya una √∫nica instrucci√≥n. De este modo, se queda preparado para a√±adir m√°s contenido en el futuro sin provocar *bugs*.

``` php
<?php
$hora = 8; // La hora en formato de 24 horas
if ($hora === 8) {
    echo "Suena el despertador.";
}
echo "<br>";
if ($hora === 8)
    echo "Suena el despertador.";
?>
```

Las condiciones compuesta mediante `if-else`:

``` php
<?php
$hora = 17; // La hora en formato de 24 horas
if ($hora <= 12) {
    echo "Son las " . $hora . " de la ma√±ana";
} else {
    echo "Son las " . ($hora - 12) . " de la tarde";
}
?>
```

Las condiciones anidadas mediante `if-else if-else`:

``` php
<?php
$hora = 14; // La hora en formato de 24 horas
if ($hora === 8) {
    echo "Es la hora de desayunar.";
} else if ($hora === 14) {
    echo "Es la hora de la comida.";
} else if ($hora === 21) {
    echo "Es la hora de la cena.";
} else {
    echo "Ahora no toca comer.";
}
?>
```

La sentencia `switch` tambi√©n permite trabajar con condiciones m√∫ltiples:

``` php
<?php
$hora = 14; // La hora en formato de 24 horas
switch ($hora) {
    case 9:
        echo "Es la hora de desayunar.";
        break;
    case 14:
        echo "Es la hora de la comida.";
        break;
    case 21:
        echo "Es la hora de la cena.";
        break;
    default:
        echo "Ahora no toca comer";
}
?>
```

!!! warning "No olvides el `break`"
    Un error muy com√∫n es olvidar la instrucci√≥n `break` tras cada caso. Si no lo ponemos, ejecutar√° el siguiente caso autom√°ticamente.

Finalmente, tambi√©n tenemos el operador ternario `condici√≥n ? valorTrue : valorFalse`:

``` php
<?php
$hora = 14;
$formato = ($hora > 12) ? 24 : 12;
echo "El formato es de $formato horas"
?>
```

Si queremos comprobar si una variable tiene valor y si no darle un valor determinado, usaremos el operador `?:` (se conoce como el operador *Elvis* - <https://en.wikipedia.org/wiki/Elvis_operator>) con la sint√°xis `expresi√≥n ?: valorSiVacio`:

``` php
<?php
$nombre = $_GET['nombre'] ?: "desconocido"
?>
```

**Condicionales embebidos en HTML**

Lo visto anteriormente, est√° pensado m√°s para c√≥digo PHP puro. Si queremos incluir condicionales en un documento HTML, lo haremos de la siguiente forma:

```html
<!DOCTYPE html>
...
<body>
    <?php
     $num1=5;
     ....

    ?>
    //Una opci√≥n es el Operador ternario, para condiciones simples, y evitando que las l√≠neas no sean muy largas
    <p>El n√∫mero es <?php echo ($num1 > 10) ? "mayor que 10" : "menor o igual que 10"; ?></p>

    //Otra opci√≥n es el if-else, para condiciones m√°s complejas
    // Los bloques if-else en una sola l√≠nea, deben finalizar con `:` y no con `{}`.
    //De esta forma el c√≥digo queda m√°s limpio y legible.

    <?php if ($num1 > 10) : ?>  # (1)!
        <p>El n√∫mero es mayor que 10</p>
    <?php elseif ($num1 > 30) : ?>
        <p>El n√∫mero es mayor que 30</p>
    <?php else : ?>
        <p>El n√∫mero es menor o igual que 10</p>
    <?php endif; ?>
</body>
```

## Bucles

Mediante la instrucci√≥n `while`:

``` php
<?php
$i = 1;
while ($i <= 10) {
    echo "L√≠nea " . $i;
    echo "<br>";
    $i++;
}
?>
```

Mediante la instrucci√≥n `do-while`:

``` php
<?php
do {
    $dado = rand(1, 6);
    // rand() devuelve un valor aleatorio 
    echo "Tirando el dado... ";
    echo "ha salido un " . $dado . ".";
    echo "<br>";
} while ($dado != 5);
echo "¬°Bien! Saco una ficha de casa.";
?>
```

Mediante la instrucci√≥n `for`:

``` php
<?php
// Bucle ascendente
for ($i = 1; $i <= 10; $i++) {
    echo "L√≠nea " . $i;
    echo "<br>";
}

// Bucle descendente
for ($i = 10; $i >= 0; $i--) {
    echo "L√≠nea " . $i;
    echo "<br>";
}
?>
```

M√°s adelante estudiaremos el bucle `foreach` para recorrer arrays.

PHP, del mismo modo que Java y C, permite romper los bucles mediante la instrucci√≥n `break`.
A su vez, `continue` permite saltar a la siguiente iteraci√≥n.

!!! danger "Si puedes, evita `break` y `continue`"
    Personalmente, no me gusta su uso. Prefiero el uso de variables *flag* para controlar la salida de los bucles. Por ejemplo:

    ``` php
    <?php
    $salir = false;
    for ($i = 1; $i <= 10 && !$salir; $i++) {
      if ($i === 5) {
        echo "Salgo cuando i=5";
        $salir = true;
      }
    }
    ?>
    ```

**Bucloes embebidos en HTML**

Al igual que los condicionales, los bucles tambi√©n se pueden incluir en un documento HTML, evitando el uso de echo para mostrar el contenido. Por ejemplo:

```html
<!DOCTYPE html>
...
<body>
    <?php
     $num1=5;
     ....

    ?>
    // El bucle for, para una lista de elementos
    <ul>
        <?php for ($i = 1; $i <= 10; $i++) : ?>
            <li>Elemento <?php echo $i; ?></li>
        <?php endfor; ?>
    </ul>

    // El bucle while, para una lista de elementos
    // Las variables de iteraci√≥n, se declar√°n en la misma l√≠nea, para que no se pierda la referencia, y se incrementan al final del bucle
    <ul>
        <?php $i = 1; while ($i <= 10) : ?>
            <li>Elemento <?php echo $i; ?></li>
        <?php $i++; endwhile; ?>
    </ul>

    // El bucle do-while, para una lista de elementos
    <ul>
        <?php $i = 1; do : ?>
            <li>Elemento <?php echo $i; ?></li>
        <?php $i++; endwhile; ?>
    </ul>
</body>
```

Tambi√©n se pueden mezclar condicionales y bucles en un mismo documento HTML, como en el siguiente ejemplo, donde se muestran las tablas de multiplicar en una lista desordenada, solo para los n√∫meros pares:

```html
<!DOCTYPE html>
...
<body>
    <?php
     $num1=5;
     ....

    ?>
    <ul>
        <?php for ($i = 1; $i <= 10; $i++) : ?>
            <?php if ($i % 2 == 0) : ?>
                <li>Tabla del <?= $i; ?></li>
                <ul>
                    <?php for ($j = 1; $j <= 10; $j++) : ?>
                        <li><?= $i . " x " . $j . " = " . ($i * $j); ?></li>
                    <?php endfor; ?>
                </ul>
            <?php endif; ?>
        <?php endfor; ?>
    </ul>

</body>
```

## Arrays

Para almacenar datos compuestos, podemos utilizar tanto arrays sencillos como arrays asociativos (similares a un mapa). En realidad todos los arrays son mapas ordenados compuestos de pares clave-valor.

!!! caution "Cuidado con mezclar tipos"
    Como el tipado es din√°mico, nuestros arrays pueden contenedor datos de diferentes tipos. No se recomienda mezclar los tipos.

Del mismo modo que Java, se definen mediante corchetes, son *0-index*, y se puede asignar un valor a un posici√≥n determinada:

``` php
<?php
$frutas = array("naranja", "pera", "manzana");

$frutas2 = ["naranja", "pera", "manzana"];

$frutas3 = [];
$frutas3[0] = "naranja";
$frutas3[1] = "pera";
$frutas3[] = "manzana"; // lo a√±ade al final
```

Podemos obtener el tama√±o del array mediante la funci√≥n `count(array)`. Para recorrer el array haremos uso de un bucle `for`:

``` php
<?php
$tam = count($frutas); // tama√±o del array

for ($i=0; $i<count($frutas); $i++) {
    echo "Elemento $i: $frutas[$i] <br />";
}
```

Otra forma de recorrer los arrays, incluso m√°s elegante, es hacer uso de `foreach`. Su sintaxis es `foreach (array as elemento)`:

``` php
<?php
// Mediante foreach no necesitamos saber el tama√±o del array
foreach ($frutas as $fruta) {
    echo "$fruta <br />";
}
```


#### Arrays asociativos

Cada elemento es un par clave-valor. En vez de acceder por la posici√≥n, lo hacemos mediante una clave. As√≠ pues, para cada clave se almacena un valor.

A la hora de recorrer este tipo de arrays, mediante `foreach` separamos cada elemento en una pareja `clave => valor`:

``` php
<?php
$capitales = ["Italia" => "Roma",
    "Francia" => "Paris",
    "Portugal" => "Lisboa"];
$capitalFrancia = $capitales["Francia"]; // se accede al elemento por la clave, no la posici√≥n

$capitales["Alemania"] = "Berl√≠n"; // a√±adimos un elemento

echo "La capital de Francia es $capitalFrancia <br />";
echo "La capital de Francia es {$capitales["Francia"]} <br />";

$capitales[] = "Madrid"; // se a√±ade con la clave 0 !!! ¬°¬°¬°No asignar valores sin clave!!!

foreach ($capitales as $valor) { // si recorremos un array asociativo, mostraremos los valores
    echo "$valor <br />";
}

foreach ($capitales as $pais => $ciudad) { // separamos cada elemento en clave => valor
    echo "$pais : $ciudad <br />";
}
```

#### Operaciones

Las operaciones m√°s importantes que podemos realizar con arrays son:

* `print_r($array)`: muestra el contenido de todo el `$array`. Si queremos mostrar el contenido con un formato determinado, hemos de recorrer el array con `foreach`.
* `var_dump($mixed)`: muestra el contenido del elemento recibido. Muestra m√°s informaci√≥n que `print_r`.
* `$elem = array_pop($array)`: elimina el √∫ltimo `$elemento`
* `array_push($array, $elem)`: a√±ade un `$elemento` al final
* `$booleano = in_array($elem, $array)`: averigua si `$elem` est√° en el `$array`

=== "PHP"

    ``` php
    <?php
    $frutas = ["naranja", "pera", "manzana"];

    array_push($frutas, "pi√±a");
    print_r($frutas);

    $ultFruta = array_pop($frutas);
    if (in_array("pi√±a", $frutas)) {
        echo "<p>Queda pi√±a</p>";
    } else {
        echo "<p>No queda pi√±a</p>";
    }
    print_r($frutas);
    ```

=== "Consola"

    ``` console
    Array
    (
      [0] => naranja
      [1] => pera
      [2] => manzana
      [3] => pi√±a
    )
    <p>No queda pi√±a</p>
    Array
    (
      [0] => naranja
      [1] => pera
      [2] => manzana
    )
    ```

* `$claves = array_keys($array)`: devuelve las claves del `$array` asociativo
* `$tam = count($array)`: devuelve el tama√±o de `$array`
* `sort($array)`: ordena los elementos del `$array`
* `isset($array[elemento])`: indica si existe/tiene valor elemento dentro del array
* `unset($array[elemento])`: elimina el elemento del array (deja un hueco)

=== "PHP"

    ``` php
    <?php
    $capitales = [
        "Italia" => "Roma",
        "Francia" => "Paris",
        "Portugal" => "Lisboa"
    ];

    $paises = array_keys($capitales);
    print_r($paises);
    sort($paises);
    print_r($paises);

    unset($capitales["Francia"]);
    print_r($capitales);
    ```

=== "Consola"

    ``` console
    Array
    (
      [0] => Italia
      [1] => Francia
      [2] => Portugal
    )
    Array
    (
      [0] => Francia
      [1] => Italia
      [2] => Portugal
    )
    Array
    (
      [Italia] => Roma
      [Portugal] => Lisboa
    )
    ```

Al asignar un array a otro se realiza una copia. Cuidado con esta operaci√≥n que puede consumir muchos recursos.

=== "PHP"

    ``` php
    <?php
    $nombres = ["Juan", "Ana", "Pedro", "Laura"];
    $copia = $nombres;
    sort($nombres);
    print_r($nombres);
    print_r($copia);
    ```

=== "Consola"

    ``` console
    Array
    (
        [0] => Ana
        [1] => Juan
        [2] => Laura
        [3] => Pedro
    )
    Array
    (
        [0] => Juan
        [1] => Ana
        [2] => Pedro
        [3] => Laura
    )
    ```

!!! danger "Cuidado con la asignaci√≥n"
    Si hacemos esto `$nombres_copia = [$nombres]`, no estamos copiando el array, sino que estamos creando un array con un √∫nico elemento que es el array original. Es decir, anidando un array en otro. Para copiarlo, hemos de hacer `$nombres_copia = $nombres`.

**Agregar elementos a un Array**

Los elementos se pueden agregar al final, al principio, o en una posici√≥n determinada.

``` php
<?php
$frutas = ["naranja", "pera", "manzana"];
echo "Array original: " . print_r($frutas,true) . "<br>";

//Agregar al final
$frutas[] = "pi√±a"; // a√±ade al final
echo "Agregar al final con []= " . print_r($frutas,true) . "<br>";

array_push($frutas, "uva"); // a√±ade al final
echo "Agregar al final con array_push: " . print_r($frutas,true) . "<br>";

array_push($frutas, "uva", "fresa"); // a√±ade varios al final
echo "Agregar varios al final con array_push: " . print_r($frutas,true) . "<br>";

//Agregar al principio
array_unshift($frutas, "fresa"); // a√±ade al principio
echo "Agregar varios al principio con array_unshift " . print_r($frutas,true) . "<br>";

//Agregar en una posici√≥n determinada
array_splice($frutas, 2, 0, "kiwi"); // a√±ade en la posici√≥n 2, un solo valor (el 0 indica que no se elimina nada)
echo "Agregar en una posici√≥n 2 con array_splice " . print_r($frutas,true) . "<br>";

//Reemplazar un valor
$frutas[1] = "pl√°tano";  //reemplaza por el √≠ndice
echo "Reemplazar por √≠ndice[1] con √≠ndice" . print_r($frutas,true) . "<br>";

array_splice($frutas, 2, 1, "Aguacate"); // a√±ade en la posici√≥n 2, reemplaza un valor (el 1 indica que se elimina un valor)
echo "Reemplazar en posici√≥n 2 con con array_splice " . print_r($frutas,true) . "<br>";

array_splice($frutas, 1, 2, ["Sandia", "Maracuya"]); //reemplaza por la posici√≥n, varios valores (el 2 indica que se reemplazan dos valores)
echo "Reemplazar en posici√≥n 1, 2 valores con con array_splice " . print_r($frutas,true) . "<br>";
?>
```

**Borrar un Array**

Para borrar complemente un array, se puede hacer de dos formas:

- `$frutas = [];` //Asignar un array vac√≠o
- `unset($frutas);` //Eliminar la variable

Para borrar elementos, se puede hacer de tres formas:

- `unset($frutas[1]);` //Borra el elemento en la posici√≥n 1
- `array_pop($frutas);` //Borra el √∫ltimo elemento
- `array_splice($frutas, 1, 2);` //Borra desde la posici√≥n 1, 2 elementos
- `array_splice($frutas, 1);` //Borra desde la posici√≥n 1 hasta el final

En este ejemplo vemos todas las posibilidades:

``` php	
<?php
$frutas = ["naranja", "pera", "manzana"];
echo "Array original: " . print_r($frutas,true) . "<br>";

//Borrar un elemento
unset($frutas[1]); //borra el elemento en la posici√≥n 1
echo "Borrar un elemento con unset " . print_r($frutas,true) . "<br>";

//Borrar varios elementos
$frutas = ["naranja", "pera", "manzana", "kiwi", "uva"];
array_splice($frutas, 1, 2); // borra desde la posici√≥n 1, 2 elementos
echo "Borrar varios elementos con array_splice " . print_r($frutas,true) . "<br>";

//Borrar desde una posici√≥n hasta el final
$frutas = ["naranja", "pera", "manzana", "kiwi", "uva"];
array_splice($frutas, 1); // borra desde la posici√≥n 1 hasta el final
echo "Borrar desde una posici√≥n hasta el final con array_splice " . print_r($frutas,true) . "<br>";

$frutas = ["naranja", "pera", "manzana"];
echo "Array original: " . print_r($frutas,true) . "<br>";

//Borrar todos los elementos
$frutas = []; //asignar un array vac√≠o
echo "Borrar todos los elementos con asignaci√≥n =[]; " . print_r($frutas,true) . "<br>";

unset($frutas); //eliminar la variable
echo "La variable ahora es: " . print_r($frutas,true) . "<br>";  //Da error porque la variable ya no existe (Undefinied variable)
?>
```

**Unir matrices**

Unir matrices es el concepto de combinar dos o m√°s matrices en una sola, y se puede realizar de varias formas:

- `array_merge($array1, $array2);` //Combina dos o m√°s matrices
- `$array1 + $array2;` //Combina dos matrices, pero si hay claves duplicadas, se conserva la clave y el valor del primer array

Veamos un ejemplo:

``` php
<?php
$frutas = ["naranja", "pera", "manzana"];
$frutas2 = ["kiwi", "uva"];
$frutas3 = ["fresa", "sandia", "melon", "coco"];

echo "Array frutas1 : " . print_r($frutas,true) . "<br>";
echo "Array frutas2: " . print_r($frutas2,true) . "<br>";
echo "Array frutras3: " . print_r($frutas3,true) . "<br>";

//Unir arrays
$frutas4 = array_merge($frutas, $frutas2, $frutas3);
echo "Unir arrays con array_merge: " . print_r($frutas4,true) . "<br>"; 

//Utilizando el operador (+)
$frutas5 = $frutas + $frutas2 + $frutas3;
echo "Unir arrays con +: " . print_r($frutas5,true) . "<br>";
echo "Como se puede ver, el operador + no es la mejor opci√≥n para unir arrays, ya que al existir claves duplicadas, el primer array tiene las claves (0,1,2), esas se conservan del primer array y se descartan las del segundo y tercer array, excepto la √∫ltima clave del √∫ltimo array, que se conserva. <br>";
?>
```

**Operador Spread**

El operador Spread (`...`) se utiliza para descomponer un array en sus elementos. Se puede utilizar para pasar los elementos de un array a una funci√≥n (variadics), o para unir arrays, que es lo que vamos a ver en este ejemplo:

``` php
<?php
$frutas = ["naranja", "pera", "manzana"];
$frutas2 = ["kiwi", "uva"];
$frutas3 = ["fresa", "sandia", "melon", "coco"];

$frutas4 = [...$frutas, ...$frutas2, ...$frutas3];  //De esta forma se aplana el array, no se anida

echo "Unir arrays con Spread: " . print_r($frutas4,true) . "<br>";

?>
```

> Este operador es una forma mucho m√°s clara de copiar un Array, se entiende mejor que la asignaci√≥n directa. `$copia = $frutas`.


Existen much√≠simas m√°s funciones para trabajar con arrays. Puedes consultar roda la informaci√≥n en la [documentaci√≥n oficial](https://www.php.net/manual/es/ref.array.php).

!!! tip "Art√≠culos para profundizar en las operaciones con arrays"
    * Un art√≠culo muy completo (en ingl√©s) de [C√≥mo trabajar con arrays en PHP de la manera correcta](https://code.tutsplus.com/tutorials/working-with-php-arrays-in-the-right-way--cms-28606).  
    * Otro art√≠culo recomendable (en ingl√©s) es [C√≥mo ordenar arrays en PHP](https://code.tutsplus.com/tutorials/how-to-sort-arrays-in-php--cms-32313).

### Arrays bidimensionales

Consiste en un array de arrays, ya sean arrays secuenciales o asociativos. Puede haber N dimensiones.

``` php
<?php
$persona["nombre"] = "Bruce Wayne";
$persona["telefonos"] = ["966 123 456", "636 636 636"]; // array de arrays ordinarios
$persona["profesion"] = [
    "dia" => "fil√°ntropo", 
    "noche" => "caballero oscuro"
    ]; // array de arrays asociativos

echo $persona['nombre']." por la noche trabaja de ".$persona['profesion']['noche'];
```

Combinando los arrays asociativos en varias dimensiones podemos almacenar la informaci√≥n como si fuera una tabla:

``` php
<?php
$menu1 = [
    "Plato1" => "Macarrones con queso", 
    "Plato2" => "Pescado asado", 
    "Bebida" => "Coca-Cola", 
    "Postre" => "Helado de vainilla"
    ];
$menu2 = ["Plato1" => "Sopa", "Plato2" => "Lomo con patatas", "Bebida" => "Agua", "Postre" => "Arroz con leche"];
$menus = [$menu1, $menu2]; // creamos un array a partir de arrays asociativos

foreach ($menus as $menudeldia) {
  echo "Men√∫ del d√≠a<br/>";

  foreach ($menudeldia as $platos => $comida) {
    echo "$platos: $comida <br/>";
  }
}

// Para acceder a un elemento concreto se anidan los corchetes
$postre0 = $menus[0]["Postre"];
```

Tambi√©n se pueden definir arrays bidimensionales de forma m√°s directa:

``` php
<?php
$menus = [
    ["Macarrones con queso", "Pescado asado", "Coca-Cola", "Helado de vainilla"],
    ["Sopa", "Lomo con patatas", "Agua", "Arroz con leche"]
];
?>
```

Y arrays asociativos directamente:

``` php
<?php
$menus = [
    "menu-dia" => [
        "Plato1" => "Macarrones con queso", 
        "Plato2" => "Pescado asado",
        "Bebida" => "Coca-Cola", 
        "Postre" => "Helado de vainilla"
        ],
    "menu-noche" => [
        "Plato1" => "Sopa",
        "Plato2" => "Lomo con patatas",
        "Bebida" => "Agua",
        "Postre" => "Arroz con leche"
        ]
];

//Acceder al postre del men√∫ de la noche
echo $menus["menu-noche"]["Postre"];

//Recorrer los men√∫s
foreach ($menus as $menu) {
    echo "Men√∫<br/>";
    foreach ($menu as $plato => $comida) {  //$plato => $comida es la pareja clave => valor
        echo "$plato: $comida <br/>";
    }
}
?>
```

!!! danger "Cuidado con la complejidad"
    Aunque pueda parecer una buena idea crear este tipo de estructuras, es mejor utilizar objetos conjuntamente con arrays (posiblemente arrays de otros objetos) para crear estructuras complejas que permitan modelar mejor los problemas.<br>
    En el tema de [*Programaci√≥n Orientada a Objetos*](03phpoo.md) veremos c√≥mo crear clases y objetos en PHP.

## Funciones

Al no declararse los tipos de datos, los par√°metros de las funciones no tienen tipo ni se indica el tipo de dato que devuelven. El paso de par√°metros se realiza por valor, es decir, se realiza una copia de la variable.

``` php
<?php
function nombreFuncion($par1, $par2, ...) {
  // c√≥digo
  return $valor;
}

$resultado = nombreFuncion($arg1, $arg2, ‚Ä¶);
?>
```

Por ejemplo:

``` php
<?php
function diaSemana() {
    $semana = [ "lunes", "martes", "mi√©rcoles",
        "jueves", "viernes", "s√°bado", "domingo" ];
    $dia = $semana[rand(0, 6)];
    return $dia;
}

$diaCine = diaSemana();
echo "El pr√≥ximo $diaCine voy al cine.";
?>
```

### Par√°metros por referencia

Si queremos pasar un par√°metro por referencia, en la declaraci√≥n de la funci√≥n, indicaremos los par√°metros mediante el operador **`&`** para indicar la direcci√≥n de memoria de la variable.

``` php
<?php
function duplicarPorValor($argumento) {
    $argumento = $argumento * 2;
    echo "Dentro de la funci√≥n: $argumento.<br>";
}
function duplicarPorReferencia(&$argumento) {
    $argumento = $argumento * 2;
    echo "Dentro de la funci√≥n: $argumento.<br>";
}

$numero1 = 5;
echo "Antes de llamar: $numero1.<br>";
duplicarPorValor($numero1);
echo "Despu√©s de llamar: $numero1.<br>";
echo "<br>";

$numero2 = 7;
echo "Antes de llamar: $numero2.<br>";
duplicarPorReferencia($numero2);
echo "Despu√©s de llamar: $numero2.<br>";
?>
```

### Par√°metros por defecto / opcionales

Permiten asignar valores en la declaraci√≥n, y posteriormente, dejar el argumento en blanco.

``` php
<?php
function obtenerCapital($pais = "todos") {
    $capitales = array("Italia" => "Roma",
    "Francia" => "Paris",
    "Portugal" => "Lisboa");

    if ($pais == "todos") {
        return array_values($capitales);
    } else {
        return $capitales[$pais];
    }
}

print_r(obtenerCapital());
echo "<br/>";
echo obtenerCapital("Francia");
```

En el caso de convivir con otro tipo de par√°metros, los par√°metros que tienen el valor asignado por defecto siempre se colocan al final.

``` php
<?php
function saluda($nombre, $prefijo = "Sr") {
    echo "Hola ".$prefijo." ".$nombre;
}

saluda("Aitor", "Mr");
saluda("Aitor");
saluda("Marina", "Srta");
```

### Par√°metros variables

Podemos tener funciones donde en la declaraci√≥n no indiquemos la cantidad de datos de entrada.

* `$arrayArgs = func_get_args();` --> Obtiene un array con los par√°metros
* `$cantidad = func_num_args();` --> Obtiene la cantidad de par√°metros recibidos
* `$valor = func_get_arg(numArgumento);` --> Obtiene el par√°metro que ocupa la posici√≥n `numArgumento`.

Estas funciones no se pueden pasar como par√°metro a otra funci√≥n (como funciones variable, que veremos m√°s adelante). Para ello, debemos guardar previamente la funci√≥n en una variable.

``` php
<?php
function sumaParametros() {
    if (func_num_args() == 0) {
        return false;
    } else {
        $suma = 0;

        for ($i = 0; $i < func_num_args(); $i++) {
            $suma += func_get_arg($i);
        }

        return $suma;
    }
}

echo sumaParametros(1, 5, 9); // 15
?>
```

Desde PHP 5.6, se puede utilizar el operador `...` (*variadics*) el cual "disfraza" los par√°metros como un array:

``` php
<?php
function sumaParametrosMejor(...$numeros) {
    if (count($numeros) == 0) {
        return false;
    } else {
        $suma = 0;

        foreach ($numeros as $num) {
            $suma += $num;
        }

        return $suma;
    }
}

echo sumaParametrosMejor(1, 5, 9); // 15
?>
```

!!! tip "M√°s usos de `...`"
    Tambi√©n se puede utilizar para dividir un array en variables separadas para proporcionar argumentos

    ``` php
    <?php
    function suma($a, $b) {
        return $a + $b;
    }

    echo suma(...[1, 5])."<br />";

    $a = [1, 5];
    echo suma(...$a);
    ?>
    ```

### Argumentos con nombre

Desde PHP 8.0 podemos pasar los argumentos con el nombre (adem√°s de por posici√≥n, como hemos hecho hasta ahora). Los argumentos con nombre se pasan poniendo el nombre como prefijo del par√°metros separado por dos puntos: `$resultado = funcion( arg1 : valor1, arg2 : valor2);`

Esta caracter√≠stica complementa los parametros opcionales permitiendonos saltar su valor:

``` php
<?php
function funcionArgumentosNombre($a, $b = 2, $c = 4) {
¬†¬†echo "$a $b $c";
}
funcionArgumentosNombre(c: 3, a: 1); // "1 2 3"
```

Tanto los par√°metros opcionales como los obligatorios pueden tener nombre, pero lo argumentos con nombre se tienen que poner despu√©s de los que no lo tienen.

``` php
<?php
funcionArgumentosNombre(1, c: 3); // "1 2 3"
```

### Funciones tipadas

Desde PHP7 en las funciones, tanto los par√°metro como su devoluci√≥n, permiten la definici√≥n de tipos. Esto se conoce como *strict_types* (tipificaci√≥n estricta) y hay que definirlo en la primera l√≠nea de cada archivo `.php` para que el propio interprete PHP compruebe los tipos y lance errores si los tipos son incorrectos, mediante la sentencia

``` php
<?php
declare(strict_types=1);
```

As√≠ pues, vamos a  definir los tipos de los par√°metros y de los valores devueltos mediante los tipos:
`int`, `float`, `string`, `bool`, `object` y `array`.

Si una funci√≥n no devuelve nada se indica mediante el tipo `void`.

``` php
<?php
declare(strict_types=1);

function suma(int $a, int $b) : int {
    return $a + $b;
}

$num = 33;
echo suma(10, 30);
echo suma(10, $num);
echo suma("10", 30); // error por tipificaci√≥n estricta, sino dar√≠a 40
?>
```



### Alcance

Las variables definidas fuera de las funciones tienen alcance **global**: accesibles desde cualquier funci√≥n.
Los par√°metros de una funci√≥n y las variables declaradas dentro de una funci√≥n (se conocen como variables locales) s√≥lo son accesibles desde dentro de la misma funci√≥n ‚Üí alcance de **funci√≥n**.

En caso de conflicto, tienen prioridad las variables locales. Para evitar el conflicto, dentro de la funci√≥n, podemos declarar la variable como `global`.

=== "Alcance local"

    ``` php
    <?php
    function miCiudad() {
        $ciudad = "Elche";
        echo "Dentro de la funci√≥n: $ciudad.<br>";
    }

    $ciudad = "Alicante";
    echo "Antes de la funci√≥n: $ciudad.<br>";
    miCiudad();
    echo "Despu√©s de la funci√≥n: $ciudad.<br>"
    ?>
    ```

=== "Alcance global"

    ``` php
    <?php
    function miCiudad() {
        global $ciudad;
        $ciudad = "Elche";
        echo "Dentro de la funci√≥n: $ciudad.<br>";
    }
    
    $ciudad = "Alicante";
    echo "Antes de llamar: $ciudad.<br>";
    miCiudad();
    echo "Despu√©s de llamar: $ciudad.<br>"
    ?>
    ```

!!! important "No globales"
    Por favor, hay que evitar el uso de variables globales dentro de las funciones.
    En el caso de necesitarlas, es mejor pasarlas como par√°metro a las funciones.

### Funciones variable

* Permite asignar una funci√≥n a una variable.
* Nombre de la funci√≥n entre comillas.
* Si una variable va seguida de par√©ntesis, PHP buscar√° una funci√≥n con su valor.

``` php
<?php
$miFuncionSuma = "suma";
echo $miFuncionSuma(3,4); // invoca a la funci√≥n suma
?>
```

!!! info "Funciones an√≥nimas"
    PHP permite la definici√≥n y uso de funciones an√≥nimas, es decir, funciones que no tienen nombre, y se utilizan principalmente para gestionar los *callbacks*. Este tipo de funciones se utiliza mucho en **Javascript** para gestionar los eventos y promesas.

    ``` php
    <?php
    $anonima = function() {
        echo "Hola";
    };
    $anonima();

    $anonimaConParametro = function($nombre) {
        echo "Hola ".$nombre;
    };
    $anonimaConParametro("Aitor");

    // Uso de variables externas a la funci√≥n an√≥nima --> `use`
    $mensaje = "Hola";
    $miClosure = function() use ($mensaje) {
        echo $mensaje;
    };
    $miClosure();

    // Uso de par√°metros
    $holaPHP = function($arg) use ($mensaje) {
        echo $mensaje." ".$arg;
    };
    $holaPHP("PHP");
    ?>
    ```

    Desde PHP 7.4 se han introducido las funciones flecha (*arrow functions*) para simplificar su definici√≥n y uso.

    Ten√©is m√°s informaci√≥n sobre funciones an√≥nimas y flecha en el siguiente art√≠culo (en ingl√©s): [Funciones an√≥nimas y flecha en PHP](https://code.tutsplus.com/tutorials/anonymous-and-arrow-functions-in-php--cms-36725)

### Biblioteca de funciones

Podemos agrupar un conjunto de funciones en un archivo, para permitir su reutilizaci√≥n. Posteriormente, se incluye con:

* `include(archivo);` / `include_once(archivo);`
* `require(archivo);` / `require_once(archivo);`

> üî• Al `incluir` un archivo, todo su c√≥digo se `inserta` en el lugar donde se encuentra la instrucci√≥n, y las funciones, variables y clases definidas en el archivo incluido, estar√°n disponibles en el archivo que lo incluye.

Si no encuentra el archivo, `require` lanza un error fatal, `include` lo ignora
Las funciones `_once` s√≥lo se cargan una vez, si ya ha sido incluida previamente, no lo vuelve a hacer, evitando bucles.

Por ejemplo, colocamos las funciones en el archivo `biblioteca.php`:

``` php
<?php
function suma(int $a, int $b) : int {
    return $a + $b;
}

function resta(int $a, int $b) : int {
    return $a - $b;
}
?>
```

Y posteriormente en otro archivo:

``` php
<?php 
include_once("biblioteca.php");
echo suma(10,20);
echo resta(40,20);
?>
```

!!! tip "POO: otra forma de organizar funciones"
    En el tema de [*Programaci√≥n Orientada a Objetos*](03phpoo.md) veremos c√≥mo se pueden agrupar las funciones en clases, permitiendo as√≠ una mejor organizaci√≥n y reutilizaci√≥n del c√≥digo.

### Plantillas mediante `include`

Mediante el uso de la instrucci√≥n `include` tambi√©n podemos separar fragmentos de c√≥digo PHP/HTML que queramos reutilizar en nuestros sitios web y crear un sistema muy sencillo de plantillas. Por ejemplo, vamos a separar una p√°gina en tres partes, primero la parte superior en `encabezado.php`:

``` html+php
<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title><?= $titulo ?></title>
</head>
<body>
```

La parte de abajo, por ejemplo, solo va a contener HTML y la colocamos en `pie.html`:
``` html
<footer>Aitor Medrano</footer>
</body>
</html>
```

Y luego nos centramos √∫nicamente en el contenido que cambia en `pagina.php`:

```php
<?php
$titulo = "P√°gina con includes";
include("encabezado.php");
?>
<body>
<h1><?= $titulo ?></h1>
<?php
include("pie.html");
?>
</body>
```

!!! info "M√°s sobre plantillas"
    A lo largo del m√≥dulo se tratar√° este tema con m√°s profundidad, y ser√° una parte fundamental del mismo. Se ver√° c√≥mo se puede separar el c√≥digo de la vista (HTML) del procesamiento (controladores). Para ello se utilizar√° el concepto de `plantilla`.<br>
    Los `template engines` como *Twig* o *Blade* permiten el uso avanzado de plantillas llevando su utilizaci√≥n a otro nivel.<br>
    En Laravel, por ejemplo, se utiliza *Blade* como motor de plantillas.

## Funciones predefinidas

El lenguaje ofrece un abanico de funciones ya definidas, agrupadas por su funcionalidad: <https://www.php.net/manual/es/funcref.php>

### Cadenas

Ya hemos visto que se pueden crear con comillas simples (`''`, sin interpretaci√≥n) o comillas dobles (`""`, interpretan el contenido y las secuencias de escape `\n`, `\t`, `\$`, `{`, ‚Ä¶ - *magic quotes*)

``` php
<?php
"Me llamo $nombre"
"Son 30 {$moneda}s"
?>
```

Se acceden a los caracteres como si fuera un array.

``` php
<?php
$cadena = ‚ÄúYo soy Batman‚Äù;
$ygriega = $cadena[0];
?>
```

Adem√°s de `echo`, podemos mostrar las cadenas mediante la funci√≥n `printf`. Esta funci√≥n viene heredada del lenguaje C, y en la cadena se indica el tipo de dato a formatear y genera una salida formateada. Si quiero guardar el resultado en una variable, podemos utilizar `sprintf`.

``` php
<?php
$num = 33;
$nombre = "Larry Bird";
printf("%s llevaba el n√∫mero %d", $nombre, $num); // %d -> n√∫mero decimal, %s -> string
$frase = sprintf("%s llevaba el n√∫mero %d", $nombre, $num);
echo $frase
?>
```

Ten√©is muchos m√°s ejemplos en <https://www.w3schools.com/php/func_string_printf.asp>

#### Operaciones b√°sicas

Todas las funciones se pueden consultar en <https://www.php.net/manual/es/ref.strings.php>

Las m√°s importantes son:

* `strlen`: obtiene la longitud de una cadena y devuelve un n√∫mero entero
* `substr`: devuelve una subcadena de la cadena original
* `str_replace`: reemplaza caracteres en una cadena
* `strtolower` y `strtoupper`: Transforman una cadena de caracteres en la misma cadena en min√∫sculas o may√∫sculas respectivamente.

``` php
<?php
$cadena = "El caballero oscuro";
$tam = strlen($cadena);
echo "La longitud de '$cadena' es: $tam <br />";

$oscuro = substr($cadena, 13); // desde 13 al final
$caba = substr($cadena, 3, 4); // desde 3, 4 letras
$katman = str_replace("c", "k", $cadena);
echo "$oscuro $caba ahora es $katman";

echo "Grande ".strtoupper($cadena);
?>
```

Si queremos trabajar con caracteres ASCII de forma individual, son √∫tiles las funciones:

* `chr`: obtiene el car√°cter a partir de un ASCII
* `ord`: obtiene el ASCII de un car√°cter

``` php
<?php
function despues(string $letra): string {
	$asciiLetra = ord($letra);
	return chr($asciiLetra + 1);
}

echo despues("B");
?>
```

Si queremos limpiar cadenas, tenemos las funciones:

* `trim`: elimina los espacios al principio y al final
* `ltrim` / `rtrim` o `chop`: Elimina los espacios iniciales / finales de una cadena.
* `str_pad`: rellena la cadenas hasta una longitud especificada y con el car√°cter o caracteres especificados.

``` php
<?php
$cadena = " Programando en PHP ";
$limpia = trim($cadena); // "Programando en PHP"

$sucia = str_pad($limpia, 23, "."); // "Programando en PHP....."
?>
```

#### Comparando y buscando

La comparaci√≥n de cadenas puede ser con conversi√≥n de tipos mediante `==` o estricta con `===`.
Tambi√©n funcionan los operadores `<` y `>` si ambas son cadenas.
Al comparar cadenas con valores numericos podemos utilizar:

* `strcmp`: 0 iguales, <0 si `a<b` o >0 si `a>b`
* `strcasecmp`: las pasa a min√∫sculas y compara
* `strncmp` / `strncasecmp`: compara los N primeros caracteres
* `strnatcmp`: comparaciones naturales

``` php
<?php
$frase1 = "Alfa";
$frase2 = "Alfa";
$frase3 = "Beta";
$frase4 = "Alfa5";
$frase5 = "Alfa10";

var_dump( $frase1 == $frase2 ); // true
var_dump( $frase1 === $frase2 ); // true
var_dump( strcmp($frase1, $frase2) ); // 0
var_dump( strncmp($frase1, $frase5, 3) ); // 0
var_dump( $frase2 < $frase3 ); // true
var_dump( strcmp($frase2, $frase3) ); // -1
var_dump( $frase4 < $frase5 ); // false
var_dump( strcmp($frase4, $frase5) ); // 4 ‚Üí f4 > f5
var_dump( strnatcmp($frase4, $frase5) ); // -1 ‚Üí f4 < f5
?>
```

Si lo que queremos es buscar dentro de una cadena, tenemos:

* `strpos` / `strrpos`: busca en una cadena y devuelve la posici√≥n de la primera/√∫ltima ocurrencia.
* `strstr` / `strchr (alias)`: busca una cadena y devuelve la subcadena a partir de donde la ha encontrado
* `stristr`: ignora las may√∫sculas

``` php
<?php
$frase = "Quien busca encuentra, eso dicen, a veces";
$pos1 = strpos($frase, ","); // encuentra la primera coma
$pos2 = strrpos($frase, ","); // encuentra la √∫ltima coma
$trasComa = strstr($frase, ","); // ", eso dicen, a veces"
?>
```

Si queremos averiguar que contiene las cadenas, tenemos un conjunto de funciones de comprobaciones de tipo, se conocen como las funciones *ctype* que devuelven un booleano:

* `ctype_alpha` ‚Üí letras
* `ctype_alnum` ‚Üí alfanum√©ricos
* `ctype_digit` ‚Üí d√≠gitos
* `ctype_punct` ‚Üí caracteres de puntuaci√≥n, sin espacios
* `ctype_space` ‚Üí son espacios, tabulador, salto de l√≠nea

``` php
<?php
$prueba1 = "hola";
$prueba2 = "hola33";
$prueba3 = "33";
$prueba4 = ",.()[]";
$prueba5 = " ,.()[]";

echo ctype_alpha($prueba1)."<br>"; // true
echo ctype_alnum($prueba2)."<br>"; // true
echo ctype_digit($prueba3)."<br>"; // true
echo ctype_punct($prueba4)."<br>"; // true
echo ctype_space($prueba5)."<br>"; // false
echo ctype_space($prueba5[0])."<br>"; // true
?>
```

#### Trabajando con subcadenas

Si queremos romper las cadenas en trozos, tenemos:

* `explode`: convierte en array la cadena mediante un separador.
* `implode` / `join`: pasa un array a cadena con un separador
* `str_split` / `chunk_split`: pasa una cadena a una array/cadena cada X caracteres

``` php
<?php
$frase = "Quien busca encuentra, eso dicen, a veces";
$partes = explode(",", $frase);

$ciudades = ["Elche", "Aspe", "Alicante"];
$cadenaCiudades = implode(">", $ciudades);

$partes3cadena = chunk_split($frase, 3);
// Qui 
// en 
// bus 
// ca 
// ...
$partes3array = str_split($frase, 3);
// ["Qui", "en ", "bus", "ca ", "enc", ‚Ä¶] 
?>
```

Si queremos trabajar con tokens:

* `strtok(cadena, separador)`
* y dentro del bucle: `strtok(separador)`

Finalmente, para separarla en base al formato:

* `sscanf`: al rev√©s que `sprintf`, crea un array a partir de la cadena y el patr√≥n.

Finalmente, otras operaciones que podemos realizar para trabajar con subcadenas son:

* `substr_count`: n√∫mero de veces que aparece la subcadena dentro de la cadena
* `substr_replace`: reemplaza parte de la cadena a partir de su posici√≥n, y opcionalmente, longitud

``` php
<?php
$batman = "Bruce Wayne es Batman";
$empresa = substr($batman, 6, 5); // Wayne
$bes = substr_count($batman, "B"); // 2
// Bruce Wayne es camarero
$camarero1 = substr_replace($batman, "camarero", 15);
$camarero2 = substr_replace($batman, "camarero", -6); // quita 6 desde el final
// Bruno es Batman
$bruno = substr_replace($batman, "Bruno", 0, 11);
?>
```

Tambi√©n disponemos de una serie de funciones que facilitan las codificaciones desde y hacia HTML:

* `htmlentities`: convierte a entidades HTML, por ejemplo, `√°` por `&aacute;`,  `√±` por `&ntilde;`, `<` por `&lt;`, etc..
* `htmlspecialchars`: idem pero solo con los caracteres especiales (`&`, `"`, `'`, `<`, `>`, ...)
* `striptags`: elimina etiquetas HTML.
* `nl2br`: cambia saltos de l√≠nea por `<br />`.
* `rawurlencode` / `rawurldecode`: codifica/decodifica una URL (espacios, ...).

Estas funciones las utilizaremos en la unidad 4.- Programaci√≥n Web.

### Matem√°ticas

Disponemos tanto de constantes como funciones ya definidas para trabajar con operaciones matem√°ticas: <https://www.php.net/manual/es/ref.math.php>

* Constantes ya definidas
    * `M_PI`, `M_E`, `M_EULER`, `M_LN2`, `M_LOG2E`
    * `PHP_INT_MAX`, `PHP_FLOAT_MAX`
* Funciones de c√°lculo
    * `pow`, `sqrt`, `log`, `decbin`, `bindec`, `decoct`, `dechex`, `base_convert`, `max`, `min`
* Funciones trigonom√©tricas
    * `sin`, `cos`, `tan`, `deg2rad`, `rad2deg`
* Funciones para trabajar con n√∫meros aleatorios
    * `rand`, `mt_rand` (m√°s r√°pida)

Aunque la mayor√≠a de ellas son muy espec√≠ficas de problemas matem√°ticos / estad√≠sticos, es muy com√∫n que tengamos que redondear y/o formatear los c√°lculos antes de mostrarlos al usuario.

Mediante la funci√≥n `number_format(numero, cantidadDecimales, separadorDecimales, separadorMiles)` podermos pasar n√∫meros a cadena con decimales y/o separadores de decimales y/o de miles.

``` php
<?php
$nf = 1234.5678;
echo number_format($nf, 2); // 1,234.57
echo number_format($nf, 2, "M", "#"); // 1#234M57
?>
```

Para redondear, tenemos `abs` para el valor absoluto y `round` para redondear, `ceil` para aproximaci√≥n por exceso y `floor` por defecto.

``` php
<?php
$num = 7.7;
$siete = floor($num);
$ocho = ceil($num);

$otro = 4.49;
$cuatro = round($otro);
$cuatrocinco = round($otro, 1);
$cinco = round($cuatrocinco);
?>
```

### Tipos de datos

Finalmente, para realizar conversiones de datos o si queremos trabajar con tipos de datos, tenemos las siguientes funciones:

* `floatval`, `intval`, `strval`: devuelve una variable del tipo de la funci√≥n indicada
* `settype`: fuerza la conversi√≥n
* `gettype`: obtiene el tipo
* `is_int`, `is_float`, `is_string`, `is_array`, `is_object`: devuelve un booleano a partir del tipo recibido

``` php
<?php
$uno = 1;
var_dump(is_int($uno)); // true
$unofloat = floatval($uno);
settype($uno, "string");
var_dump(is_int($uno)); // false
var_dump(is_string($uno)); // true
settype($uno, "float");
var_dump(is_int($uno)); // false
var_dump(is_float($uno)); // true
var_dump(is_int(intval($uno))); // true
?>
```

## Formularios

Los formularios son los elementos de las p√°ginas web que permiten a un usuario introducir informaci√≥n en una p√°gina web. As√≠, los formularios nos permiten crear p√°ginas web PHP interactivas en las que el contenido de la p√°gina se adapta a la informaci√≥n proporcionada por el usuario.

Conceptos importantes:

- Un formulario se compone de una serie de campos de entrada, etiquetas y botones de env√≠o. 
- Los campos de entrada pueden ser de varios tipos: texto, contrase√±a, botones de radio, casillas de verificaci√≥n, men√∫s desplegables, etc. - Cada campo de entrada se identifica mediante un nombre y un valor. 
- Cuando el usuario env√≠a el formulario, los datos introducidos en los campos de entrada se env√≠an al servidor web, donde se procesan con un script PHP.

Aqu√≠ nos centraremos en c√≥mo procesar los datos no en c√≥mo se dise√±an.

En un formulario existen varios conceptos importantes:

- **Action**: es la URL a la que se enviar√°n los datos del formulario. Si no se especifica, se enviar√°n a la misma p√°gina.
- **Method**: es el m√©todo de env√≠o de los datos. Puede ser `GET` o `POST`. En el caso de `GET`, los datos se env√≠an en la URL, mientras que en el caso de `POST`, los datos se env√≠an en el cuerpo de la petici√≥n.
- **Input**: es el campo de entrada de datos. Puede ser de varios tipos: texto, contrase√±a, botones de radio, casillas de verificaci√≥n, men√∫s desplegables, etc.
- **Label**: es la etiqueta que acompa√±a al campo de entrada. Sirve para indicar al usuario qu√© tipo de informaci√≥n debe introducir en el campo.
- **Name**: es el nombre del campo de entrada. Se utiliza para identificar el campo de entrada en el script PHP que procesa los datos del formulario.


#### Trabajando con formularios

Si es una peetici√≥n tipo `GET` los datos se env√≠an via URL con el formato `var1=valor1&var2=valor2‚Ä¶`. Por ejemplo: `ejemplo.php?nombre=Bruce+apellido1=Wayne`, donde cada par√°metro se separa con `&` y el nombre y el valor con `=`, y el nobre del par√°metro es igual al valor del atributo `name` del campo de entrada.

!!! tip "Codificaci√≥n de URL"
    Los espacios en blanco se codifican como `+` o `%20`, y los caracteres especiales se codifican como `%xx`, donde `xx` es el c√≥digo ASCII del car√°cter.


Se divide en dos pasos:

1. Generar un formulario con `action='archivo.php' method='GET'`
2. En el archivo `.php` (del lado servidor) leer los datos con `$_GET['nombreVar']`

Vamos a separar siempre que podamos el c√≥digo HTML del de PHP.
Por ejemplo, el formulario lo colocamos en `saluda.html`:

``` html
<form action="saluda.php" method="get">
    <p><label for="nombre">Nombre: </label>
    <input type="text" name="nombre" id="nombre"></p>
    <p><label for="apellido1">Primer apellido:</label> 
    <input type="text" name="apellido1" id="apellido1"></p>
    <p><input type="submit" value="enviar"></p>
</form>
```

Los datos se recogen a trav√©s de variables superglobales, en este caso `$_GET` y `$_POST` (dependiendo del m√©todo de env√≠o).

Recogemos los datos en `saluda.php`:

``` php
<?php
$nombre = $_GET["nombre"];
$apellido1 = $_GET["apellido1"];

echo "Hola $nombre $apellido1";
?>
```

Si lo quisi√©ramos realizar todo en un √∫nico archivo (*lo cual no es recomendable*), podemos hacerlo as√≠:

```php
<form action="" method="get">
    <p><label for="nombre">Nombre: </label>
    <input type="text" name="nombre" id="nombre"></p>
    <p><label for="apellido1">Primer apellido:</label>
    <input type="text" name="apellido1" id="apellido1"></p>
    <input type="submit" value="enviar">
</form>
<p>
    <?php
    //isset() comprueba si una variable est√° definida y no es NULL
    if(isset($_GET['nombre'])) {
        $nombre = $_GET["nombre"];
        $apellido1 = $_GET["apellido1"];

        echo "Hola $nombre $apellido1";
    }
    ?>
</p>
```

El trabajo con formularios lo estudiaremos en profundidad en la unidad 4, y veremos que adem√°s de `GET`, podemos enviar los datos con `POST`.

## Referencias

* [Manual de PHP](https://www.php.net/manual/es/index.php)
* [PHP en 2020](https://www.jesusamieiro.com/wp-content/uploads/2020/10/20201024-hacktoberday-PHP-en-2020.pdf), por Jes√∫s Amieiro
* [Apuntes de PHP](https://www.mclibre.org/consultar/php/) de Bartolom√© Sintes, profesor del IES Abastos de Valencia
* [Gu√≠a de Estilo - PSR](http://coppeldev.github.io/php/standards/coppel.html)
* [PHP - La manera correcta](http://phpdevenezuela.github.io/php-the-right-way/)


!!! danger "¬°No te limites a copiar y pegar! ¬°Practica y experimenta con los ejercicios!"